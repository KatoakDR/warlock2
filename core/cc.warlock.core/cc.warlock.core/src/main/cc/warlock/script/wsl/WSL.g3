grammar WSL;

@parser::header {
	package cc.warlock.script.wsl;
	import java.util.ArrayList;
	import cc.warlock.script.wsl.WSLEqualityCondition.EqualityOperator;
}

@lexer::header {
	package cc.warlock.script.wsl;
}

@parser::members {
	private WSLScript script;
	private int lineNum = 1;
	public void setScript(WSLScript s) { script = s; }
}

@lexer::members {
	private enum State { base, command, condition }
	private boolean atStart = true;
	private State state = State.base;
}

script
	: (line)* EOF { script.stopScript(); }
	;

line
	: (COMMENT | l=expr
		{
			script.addLine(l); 
			System.out.print("added line " + Integer.toString(lineNum) + "\n");
		}
		)? EOL { lineNum++; }
	;

expr returns [WSLScriptLine line]
	: label=LABEL (l=expr)?
		{
			if (l == null) {
				line = new WSLScriptLine(script, lineNum);
			} else {
				line = l;
			}
		
			script.addLabel($label.text, line);
		}
	| IF conditionalExpression THEN l=expr { line = l; }
	| args=arg_list
			{
				line = new WSLScriptLine(script, lineNum);
				line.addArgs(args);
				
			}
	;

arg_list returns [ArrayList<IWSLValue> list]
	: ( data=script_data				{ list = new ArrayList<IWSLValue>(); list.add(data); } )
	| ( data=script_data l=arg_list		{ list = l; list.add(0, data); } )
	;

script_data returns [IWSLValue arg]
	: str=STRING
		{
			arg = new WSLString($str.text);
			System.out.println("STRING: \"" + $str.text + "\"");
		}
	| var=VARIABLE
		{
			arg = new WSLVariable($var.text, script);
			System.out.println("VARIABLE: \"" + $var.text + "\"");
		}
	;
	
conditionalExpression returns [IWSLValue cond]
	: arg=conditionalAndExpression  { ArrayList<IWSLValue> args = null; }
		('||' argNext=conditionalAndExpression
			{
				if(args == null) {
					args = new ArrayList<IWSLValue>();
					args.add(arg);
				}
				args.add(argNext);
			}
		)*
			{
				if(args == null)
					cond = arg;
				else
					cond = new WSLOrCondition(args);
			}
	;

conditionalAndExpression returns [IWSLValue cond]
	: arg=equalityExpression { cond = arg; } ('&&' equalityExpression)*
	;

equalityExpression returns [IWSLValue cond]
	: arg=relationalExpression
			{
				ArrayList<IWSLValue> args = null;
				ArrayList<EqualityOperator> ops = null;
			}
		(op=equalityOp argNext=relationalExpression
			{
				if(args == null) {
					args = new ArrayList<IWSLValue>();
					args.add(arg);
				}
				args.add(argNext);
				if(ops == null) {
					ops = new ArrayList<EqualityOperator>();
				}
				ops.add(op);
			}
		)*
			{
				if(args == null)
					cond = arg;
				else
					cond = new WSLEqualityCondition(args, ops);
			}
	;

equalityOp returns [EqualityOperator op]
	: ('=' | '==')		{ op = EqualityOperator.equals; }
	| ('!=' | '<>')		{ op = EqualityOperator.notequals; }
	;
	
relationalExpression returns [IWSLValue cond]
	: unaryExpression (relationalOp unaryExpression)*
	;

relationalOp
	: '>'
	| '<'
	| '>='
	| '<='
	;

unaryExpression returns [IWSLValue cond]
	: '!' unaryExpression
	| primaryExpression
	;

parenExpression
	: '(' conditionalExpression ')'
	;

primaryExpression
	: parenExpression
	| condition_value
	;

condition_value
	: NUMBER
	| TRUE
	| FALSE
	| STRING
	| VARIABLE
	;

WHITESPACE
	: { state != State.command }?=>
		WS+			{ channel = HIDDEN; }
	;
EOL
	: '\r'? '\n' { state = State.base; atStart = true; }
	;
COMMENT
	: { atStart && state == State.base }?=>
		~(NORMAL_CHAR|'%'|WS|'\n'|'\r') (~('\n'|'\r'))* { atStart = false; }
	;
LABEL
	: { state == State.base }?=>
		label=NORMAL_STRING ':'			{ setText($label.text); }
	;
VARIABLE
	: '%' var=NORMAL_STRING { setText($var.text); if(state == State.base) state = State.command; }
	;
IF
	: { state == State.base }?=> 'if' { state = State.condition; }
	;
THEN
	: { state == State.condition }?=> 'then' { state = State.base; }
	;
STRING
	: { state == State.command }?=> (~('%'|'\n'|'\r'))+
	| { state == State.base }?=> NORMAL_STRING (~(':'))=>
		{
			if(state == State.base) state = State.command;
		}
	| '%' (~(NORMAL_CHAR))=>
		{
			if(state == State.base) state = State.command;
		}
	| { state == State.condition }?=> '"' str=NQQ_STRING '"' { setText($str.text); }
	| { state == State.condition }?=> '\'' str=NQ_STRING '\'' { setText($str.text); }
	;
NUMBER
	: { state == State.condition }?=> (DIGIT)+ ('.' (DIGIT)+)?
	;
TRUE
	: { state == State.condition }?=> 'true'
	;
FALSE
	: { state == State.condition }?=> 'false'
	;

fragment WS
	: ' ' | '\t'
	;
fragment DIGIT
	: '0'..'9'
	;
fragment NORMAL_CHAR
	: 'A'..'Z'|'a'..'z'|DIGIT|'_'
	;
fragment NORMAL_STRING
	: NORMAL_CHAR+
	;
fragment NQQ_STRING
	: (~('"'))+
	;
fragment NQ_STRING
	: (~('\''))+
	;
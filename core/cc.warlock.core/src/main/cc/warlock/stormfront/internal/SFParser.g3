parser grammar SFParser;
options {
    tokenVocab=SFLexer;
}

tokens {
    ELEMENT;
    ATTRIBUTE;
}

@header {
	package cc.warlock.stormfront.internal;
	import cc.warlock.stormfront.internal.StormFrontProtocolHandler;
	import java.util.Hashtable;
}

@members {
    protected boolean tagMode = false;
    protected StormFrontProtocolHandler handler;
    protected Hashtable<String,String> currentAttributes = new Hashtable<String,String>();
    
    public void setHandler(StormFrontProtocolHandler h) {
    	handler = h;
    }
}

document : element* ;

element
    : startTag
        (element
        | data=PCDATA { handler.characters($data.text.toCharArray(), 0, $data.text.length()); }
        )*
        endTag
    | emptyElement
    | data=PCDATA { handler.characters($data.text.toCharArray(), 0, $data.text.length()); }
    ;

startTag  : TAG_START_OPEN name=GENERIC_ID (attribute)* TAG_CLOSE { System.out.println("got tag " + $name.text); handler.startElement($name.text, currentAttributes); }
	;

attribute  : name=GENERIC_ID ATTR_EQ value=ATTR_VALUE { currentAttributes.put($name.text, $value.text.substring(1, $value.text.length() - 1)); };

endTag :  TAG_END_OPEN name=GENERIC_ID TAG_CLOSE { handler.endElement($name.text); currentAttributes.clear(); }
	;

emptyElement : TAG_START_OPEN name=GENERIC_ID  (attribute)* TAG_EMPTY_CLOSE { handler.startElement($name.text, currentAttributes); handler.endElement($name.text); }
	;
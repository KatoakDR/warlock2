grammar WSL;


@parser::header {
	package cc.warlock.core.stormfront.script.wsl;
	import java.util.ArrayList;
	import cc.warlock.core.stormfront.script.wsl.WSLEqualityCondition.EqualityOperator;
	import cc.warlock.core.stormfront.script.wsl.WSLRelationalCondition.RelationalOperator;
}

@lexer::header {
	package cc.warlock.core.stormfront.script.wsl;
}

@parser::members {
	private WSLScript script;
	private int lineNum = 1;
	public void setScript(WSLScript s) { script = s; }
}

@lexer::members {
	private enum State { base, command, condition, nq_string, nqq_string }
	private boolean atStart = true;
	private State state = State.base;
}

script
	: line (EOL line)* EOF
	;

line
	: (COMMENT | l=expr
		{
			script.addLine(l);
		}
		)? { lineNum++; }
	;

expr returns [WSLScriptLine line]
	: label=LABEL (l=expr)?
		{
			if (l == null) {
				line = new WSLScriptLine(lineNum);
			} else {
				line = l;
			}
		
			script.addLabel($label.text, line);
		}
	| (IF cond=conditionalExpression THEN)?
		args=value_list
			{
				line = new WSLScriptLine(lineNum);
				line.setValue(args);
				if(cond != null)
					line.setCondition(cond);
			}
	;

value_list returns [IWSLValue value]
	: l=value_list_helper
			{
				if(l.size() > 1)
					value = new WSLList(l);
				else
					value = l.get(0);
			}
	;

value_list_helper returns [ArrayList<IWSLValue> list]
	: ( data=script_value						{ list = new ArrayList<IWSLValue>(); list.add(data); } )
	| ( data=script_value l=value_list_helper	{ list = l; list.add(0, data); } )
	;

script_value returns [IWSLValue value]
	: v=STRING	{ value = new WSLString($v.text); }
	| v=VARIABLE { value = new WSLVariable($v.text, script); }
	| v=NUMBER		{ value = new WSLNumber($v.text); }
	| TRUE			{ value = new WSLBoolean(true); }
	| FALSE			{ value = new WSLBoolean(false); }
	;
	
conditionalExpression returns [IWSLValue cond]
	: arg=conditionalAndExpression  { ArrayList<IWSLValue> args = null; }
		(('||' | 'or') argNext=conditionalAndExpression
			{
				if(args == null) {
					args = new ArrayList<IWSLValue>();
					args.add(arg);
				}
				args.add(argNext);
			}
		)*
			{
				if(args == null)
					cond = arg;
				else
					cond = new WSLOrCondition(args);
			}
	;

conditionalAndExpression returns [IWSLValue cond]
	: arg=equalityExpression { ArrayList<IWSLValue> args = null; }
		(('&&' | 'and') argNext=equalityExpression
			{
				if(args == null) {
					args = new ArrayList<IWSLValue>();
					args.add(arg);
				}
				args.add(argNext);
			}
		)*
			{
				if(args == null)
					cond = arg;
				else
					cond = new WSLAndCondition(args);
			}
	;

equalityExpression returns [IWSLValue cond]
	: arg=relationalExpression
			{
				ArrayList<IWSLValue> args = null;
				ArrayList<EqualityOperator> ops = null;
			}
		(op=equalityOp argNext=relationalExpression
			{
				if(args == null) {
					args = new ArrayList<IWSLValue>();
					args.add(arg);
				}
				args.add(argNext);
				if(ops == null) {
					ops = new ArrayList<EqualityOperator>();
				}
				ops.add(op);
			}
		)*
			{
				if(args == null)
					cond = arg;
				else
					cond = new WSLEqualityCondition(args, ops);
			}
	;

equalityOp returns [EqualityOperator op]
	: ('=' | '==')		{ op = EqualityOperator.equals; }
	| ('!=' | '<>')		{ op = EqualityOperator.notequals; }
	;
	
relationalExpression returns [IWSLValue cond]
	: arg=unaryExpression
			{
				ArrayList<IWSLValue> args = null;
				ArrayList<RelationalOperator> ops = null;
			}
		(op=relationalOp argNext=unaryExpression
			{
				if(args == null) {
					args = new ArrayList<IWSLValue>();
					args.add(arg);
				}
				args.add(argNext);
				if(ops == null) {
					ops = new ArrayList<RelationalOperator>();
				}
				ops.add(op);
			}
		)*
			{
				if(args == null || ops == null)
					cond = arg;
				else
					cond = new WSLRelationalCondition(args, ops);
			}
	;

relationalOp returns [RelationalOperator op]
	: '>'			{ op = RelationalOperator.GreaterThan; }
	| '<'			{ op = RelationalOperator.LessThan; }
	| '>='			{ op = RelationalOperator.GreaterThanEqualTo; }
	| '<='			{ op = RelationalOperator.LessThanEqualTo; }
	| 'contains'	{ op = RelationalOperator.Contains; }
	;

unaryExpression returns [IWSLValue cond]
	: ('!' | 'not') arg=unaryExpression	{ cond = new WSLNotCondition(arg); }
	| ('exist' | 'exists') name=VARIABLE	{ cond = new WSLExistsCondition($name.text, script); }
	| arg=primaryExpression		{ cond = arg; }
	;

parenExpression returns [IWSLValue cond]
	: '(' arg=conditionalExpression ')'		{ cond = arg; }
	;

primaryExpression returns [IWSLValue cond]
	: arg=parenExpression	{ cond = arg; }
	| l=value_list			{ cond = l; }
	;



WHITESPACE
	: { state == State.base || state == State.condition }?=>
		WS+			{ channel = HIDDEN; }
	;
EOL
	: '\r'? '\n' { state = State.base; atStart = true; }
	;
COMMENT
	: { atStart }?=>
		~(NORMAL_CHAR|'%'|WS|'\n'|'\r') (~('\n'|'\r'))* { atStart = false; }
	;
LABEL
	: { state == State.base }?=>
		label=LABEL_STRING ':'			{ setText($label.text); }
	;
VARIABLE
	: ('%' var=NORMAL_STRING '%'? { setText($var.text); }
		| '$' NORMAL_STRING )
			{
				if(state == State.base) { state = State.command; atStart = false; }
			}
	;
IF
	: { state == State.base }?=> ('i' | 'I') ('f' | 'F') { state = State.condition; atStart = false; }
	;
THEN
	: { state == State.condition }?=> ('t' | 'T') ('h' | 'H') ('e' | 'E') ('n' | 'N') { state = State.base; }
	;
STRING
	: { state == State.command }?=> (~('%'|'$'|'\n'|'\r'))+
	| { state == State.base }?=> NORMAL_STRING (~(':'|'%'|'$'|'\n'|'\r'))=>
		{
			state = State.command;
			atStart = false;
		}
	| ('%'|'$') (~(NORMAL_CHAR))=>
		{
			if(state == State.base) { state = State.command; atStart = false; }
		}
	| { state == State.nqq_string }?=> (~('"'|'%'|'$'|'\n'|'\r'))+
	| { state == State.nq_string }?=> (~('\''|'%'|'$'|'\n'|'\r'))+
	;
QUOTE
	: { state == State.condition }?=> '"'	{ state = State.nqq_string; channel = HIDDEN; }
	| { state == State.condition }?=> '\''	{ state = State.nq_string; channel = HIDDEN; }
	| { state == State.nqq_string }?=> '"'	{ state = State.condition; channel = HIDDEN; }
	| { state == State.nq_string }?=> '\''	{ state = State.condition; channel = HIDDEN; }
	;
NUMBER
	: { state == State.condition }?=> '-'? (DIGIT)+ ('.' (DIGIT)+)?
	;
TRUE
	: { state == State.condition }?=> ('t' | 'T') ('r' | 'R') ('u' | 'U') ('e' | 'E')
	;
FALSE
	: { state == State.condition }?=> ('f' | 'F') ('a' | 'A') ('l' | 'L') ('s' | 'S') ('e' | 'E')
	;

fragment WS
	: ' ' | '\t'
	;
fragment DIGIT
	: '0'..'9'
	;
fragment NORMAL_CHAR
	: ('A'..'Z'|'a'..'z'|DIGIT|'_')
	;
fragment NORMAL_STRING
	: NORMAL_CHAR+
	;
fragment LABEL_STRING
	: NORMAL_CHAR (~(WS|':'|'\n'|'\r'|'%'|'$'))*
	;
grammar WSL;


@parser::header {
	package cc.warlock.core.stormfront.script.wsl;
	import java.util.ArrayList;
	import cc.warlock.core.stormfront.script.wsl.WSLEqualityCondition.EqualityOperator;
	import cc.warlock.core.stormfront.script.wsl.WSLRelationalCondition.RelationalOperator;
}

@lexer::header {
	package cc.warlock.core.stormfront.script.wsl;
}

@parser::members {
	private WSLScript script;
	private int lineNum = 1;
	public void setScript(WSLScript s) { script = s; }
}

@lexer::members {
	private enum State { base, variableReplace, condition, action, quoted }
	private boolean atStart = true;
	private State state = State.base;
}

script
	: line (EOL line)* EOF
	;

line
	: (label=LABEL)? c=expr
		{
			script.addCommand(c);
			if(label != null) {
				int existingLine = script.labelLineNumber($label.text);
				if(existingLine != -1)
					script.echo("Redefinition of label \"" + $label.text + "\" on line " + lineNum + ", originally defined on line " + existingLine);
				script.addLabel($label.text, c);
			}
			lineNum++;
		}
	;

expr returns [WSLAbstractCommand command]
	: IF cond=conditionalExpression THEN c=expr
		{
			command = new WSLCondition(lineNum, script, cond, c);
		}
	| ACTION c=expr WHEN args=value_list
		{
			command = new WSLAction(lineNum, script, c, args);
		}
	| ACTION REMOVE args=value_list
		{
			command = new WSLActionRemove(lineNum, script, args);
		}
	| ACTION CLEAR
		{
			command = new WSLActionClear(lineNum, script);
		}
	| args=value_list
		{
			command = new WSLCommand(lineNum, script, args);
		}
	| { command = new WSLCommand(lineNum, script, null); }
	;

value_list returns [IWSLValue value]
	: l=value_list_helper
			{
				if(l.size() > 1)
					value = new WSLList(l);
				else
					value = l.get(0);
			}
	;

value_list_helper returns [ArrayList<IWSLValue> list]
	: ( data=script_value						{ list = new ArrayList<IWSLValue>(); list.add(data); } )
	| ( data=script_value l=value_list_helper	{ list = l; list.add(0, data); } )
	;

script_value returns [IWSLValue value]
	: v=STRING			{ value = new WSLString($v.text); }
	| v=VARIABLE		{ value = new WSLVariable($v.text, script); }
	| v=LOCAL_VARIABLE	{ value = new WSLLocalVariable($v.text, script); }
	| v=NUMBER			{ value = new WSLNumber($v.text); }
	| TRUE				{ value = new WSLBoolean(true); }
	| FALSE				{ value = new WSLBoolean(false); }
	;
	
conditionalExpression returns [IWSLValue cond]
	: arg=conditionalAndExpression  { ArrayList<IWSLValue> args = null; }
		(OR argNext=conditionalAndExpression
			{
				if(args == null) {
					args = new ArrayList<IWSLValue>();
					args.add(arg);
				}
				args.add(argNext);
			}
		)*
			{
				if(args == null)
					cond = arg;
				else
					cond = new WSLOrCondition(args);
			}
	;

conditionalAndExpression returns [IWSLValue cond]
	: arg=equalityExpression { ArrayList<IWSLValue> args = null; }
		(AND argNext=equalityExpression
			{
				if(args == null) {
					args = new ArrayList<IWSLValue>();
					args.add(arg);
				}
				args.add(argNext);
			}
		)*
			{
				if(args == null)
					cond = arg;
				else
					cond = new WSLAndCondition(args);
			}
	;

equalityExpression returns [IWSLValue cond]
	: arg=relationalExpression
			{
				ArrayList<IWSLValue> args = null;
				ArrayList<EqualityOperator> ops = null;
			}
		(op=equalityOp argNext=relationalExpression
			{
				if(args == null) {
					args = new ArrayList<IWSLValue>();
					args.add(arg);
				}
				args.add(argNext);
				if(ops == null) {
					ops = new ArrayList<EqualityOperator>();
				}
				ops.add(op);
			}
		)*
			{
				if(args == null)
					cond = arg;
				else
					cond = new WSLEqualityCondition(args, ops);
			}
	;

equalityOp returns [EqualityOperator op]
	: ('=' | '==')		{ op = EqualityOperator.equals; }
	| ('!=' | '<>')		{ op = EqualityOperator.notequals; }
	;
	
relationalExpression returns [IWSLValue cond]
	: arg=unaryExpression
			{
				ArrayList<IWSLValue> args = null;
				ArrayList<RelationalOperator> ops = null;
			}
		(op=relationalOp argNext=unaryExpression
			{
				if(args == null) {
					args = new ArrayList<IWSLValue>();
					args.add(arg);
				}
				args.add(argNext);
				if(ops == null) {
					ops = new ArrayList<RelationalOperator>();
				}
				ops.add(op);
			}
		)*
			{
				if(args == null || ops == null)
					cond = arg;
				else
					cond = new WSLRelationalCondition(args, ops);
			}
	;

relationalOp returns [RelationalOperator op]
	: '>'			{ op = RelationalOperator.GreaterThan; }
	| '<'			{ op = RelationalOperator.LessThan; }
	| '>='			{ op = RelationalOperator.GreaterThanEqualTo; }
	| '<='			{ op = RelationalOperator.LessThanEqualTo; }
	| CONTAINS		{ op = RelationalOperator.Contains; }
	;

unaryExpression returns [IWSLValue cond]
	: NOT arg=unaryExpression	{ cond = new WSLNotCondition(arg); }
	| EXISTS arg=unaryExpression	{ cond = new WSLExistsCondition(arg); }
	| arg=primaryExpression		{ cond = arg; }
	;

parenExpression returns [IWSLValue cond]
	: '(' arg=conditionalExpression ')'		{ cond = arg; }
	;

primaryExpression returns [IWSLValue cond]
	: arg=parenExpression	{ cond = arg; }
	| l=value_list			{ cond = l; }
	;



WHITESPACE
	: { state == State.base || state == State.condition }?=>
		WS+			{ channel = HIDDEN; }
	;
EOL
	: '\r'? '\n' { state = State.base; atStart = true; }
	;
COMMENT
	: { atStart }?=>
		('#'|';') (~('\n'|'\r'))* { channel = HIDDEN; }
	;
VARIABLE
	: '%' var=WORD '%'?
			{
				setText($var.text);
				if(state == State.base) { state = State.variableReplace; atStart = false; }
			}
	;
LOCAL_VARIABLE
	:  '$' var=WORD '$'?
			{
				setText($var.text);
				if(state == State.base) { state = State.variableReplace; atStart = false; }
			}
	;
IF
	: { state == State.base }?=> 'if' { state = State.condition; atStart = false; }
	;
THEN
	: { state == State.condition }?=> 'then' { state = State.base; }
	;
OR
	: { state == State.condition }?=> ('||' | 'or')
	;
AND
	: { state == State.condition }?=> ('&&' | 'and')
	;
NOT
	: { state == State.condition }?=> ('!' | 'not')
	;
EXISTS
	: { state == State.condition }?=> ('exists')
	;
CONTAINS
	: { state == State.condition }?=> ('contains' | 'indexof')
	;
ACTION
	: { state == State.base }?=> 'action' WS+ { state = State.action; atStart = false; }
	;
WHEN
	: { state == State.action }?=> 'when' { state = State.variableReplace; }
	;
REMOVE
	: { state == State.action }?=> 'remove' { state = State.variableReplace; }
	;
CLEAR
	: { state == State.action }?=> 'clear' { state = State.variableReplace; }
	;
TRUE
	: { state == State.condition || state == State.action }?=> 'true'
	;
FALSE
	: { state == State.condition || state == State.action }?=> 'false'
	;
NUMBER
	: { state == State.condition || state == State.action }?=> '-'? (DIGIT)+ ('.' (DIGIT)+)?
	;
STRING
	: { state == State.variableReplace }?=> (~('%'|'$'|'\n'|'\r'))+
	| { state == State.base }?=> WORD
		{
			state = State.variableReplace;
			atStart = false;
		}
	| ('%%'|'$$')
		{
			setText(getText().substring(0,1));
			if(state == State.base) { state = State.variableReplace; atStart = false; }
		}
	| ('%'|'$')
		{
			if(state == State.base) { state = State.variableReplace; atStart = false; }
		}
	| { state == State.condition }?=> WORD
	| { state == State.action }?=> (~(WS|'%'|'$'|'\n'|'\r'))+ | WS+
	| { state == State.condition }?=> '"' { state = State.quoted; setText(""); }
	| { state == State.quoted }?=> '"' { state = State.condition; channel = HIDDEN; }
	| { state == State.quoted }?=> (~('"'|'%'|'$'|'\n'|'\r'|'\\'))+ | ('\\' str=ANY { setText($str.text); })
	;
LABEL
	: label=LABEL_STRING ':'			{ setText($label.text); atStart = false; }
	;
	
fragment WS
	: ' ' | '\t'
	;
fragment DIGIT
	: '0'..'9'
	;
fragment ANY
	: .
	;
fragment WORD_CHAR
	: ('a'..'z'|DIGIT|'_')
	;
fragment WORD
	: WORD_CHAR+
	;
fragment LABEL_STRING
	: (WORD_CHAR|'.'|'-')+
	;
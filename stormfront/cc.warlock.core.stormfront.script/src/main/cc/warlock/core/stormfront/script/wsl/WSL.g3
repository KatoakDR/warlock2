grammar WSL;


@parser::header {
	package cc.warlock.core.stormfront.script.wsl;
	import java.util.ArrayList;
	import cc.warlock.core.stormfront.script.wsl.WSLEqualityCondition.EqualityOperator;
	import cc.warlock.core.stormfront.script.wsl.WSLRelationalCondition.RelationalOperator;
}

@lexer::header {
	package cc.warlock.core.stormfront.script.wsl;
}

@parser::members {
	private WSLScript script;
	private int lineNum = 1;
	public void setScript(WSLScript s) { script = s; }
}

@lexer::members {
	private enum State { base, command, condition, action }
	private boolean atStart = true;
	private State state = State.base;
}

script
	: line (EOL line)* EOF
	;

line
	: (l=expr
		{
			script.addLine(l);
		}
		)? { lineNum++; }
	;

expr returns [WSLScriptLine line]
	: label=LABEL (l=expr)?
		{
			if (l == null) {
				line = new WSLScriptLine(lineNum);
			} else {
				line = l;
			}
		
			script.addLabel($label.text, line);
		}
	| (IF cond=conditionalExpression THEN)?
		args=value_list
			{
				line = new WSLScriptLine(lineNum);
				line.setValue(args);
				if(cond != null)
					line.setCondition(cond);
			}
	;

value_list returns [IWSLValue value]
	: l=value_list_helper
			{
				if(l.size() > 1)
					value = new WSLList(l);
				else
					value = l.get(0);
			}
	;

value_list_helper returns [ArrayList<IWSLValue> list]
	: ( data=script_value						{ list = new ArrayList<IWSLValue>(); list.add(data); } )
	| ( data=script_value l=value_list_helper	{ list = l; list.add(0, data); } )
	;

script_value returns [IWSLValue value]
	: v=STRING			{ value = new WSLString($v.text); }
	| v=VARIABLE		{ value = new WSLVariable($v.text, script); }
	| v=LOCAL_VARIABLE	{ value = new WSLLocalVariable($v.text, script); }
	| v=NUMBER			{ value = new WSLNumber($v.text); }
	| TRUE				{ value = new WSLBoolean(true); }
	| FALSE				{ value = new WSLBoolean(false); }
	;
	
conditionalExpression returns [IWSLValue cond]
	: arg=conditionalAndExpression  { ArrayList<IWSLValue> args = null; }
		(('||' | 'or') argNext=conditionalAndExpression
			{
				if(args == null) {
					args = new ArrayList<IWSLValue>();
					args.add(arg);
				}
				args.add(argNext);
			}
		)*
			{
				if(args == null)
					cond = arg;
				else
					cond = new WSLOrCondition(args);
			}
	;

conditionalAndExpression returns [IWSLValue cond]
	: arg=equalityExpression { ArrayList<IWSLValue> args = null; }
		(('&&' | 'and') argNext=equalityExpression
			{
				if(args == null) {
					args = new ArrayList<IWSLValue>();
					args.add(arg);
				}
				args.add(argNext);
			}
		)*
			{
				if(args == null)
					cond = arg;
				else
					cond = new WSLAndCondition(args);
			}
	;

equalityExpression returns [IWSLValue cond]
	: arg=relationalExpression
			{
				ArrayList<IWSLValue> args = null;
				ArrayList<EqualityOperator> ops = null;
			}
		(op=equalityOp argNext=relationalExpression
			{
				if(args == null) {
					args = new ArrayList<IWSLValue>();
					args.add(arg);
				}
				args.add(argNext);
				if(ops == null) {
					ops = new ArrayList<EqualityOperator>();
				}
				ops.add(op);
			}
		)*
			{
				if(args == null)
					cond = arg;
				else
					cond = new WSLEqualityCondition(args, ops);
			}
	;

equalityOp returns [EqualityOperator op]
	: ('=' | '==')		{ op = EqualityOperator.equals; }
	| ('!=' | '<>')		{ op = EqualityOperator.notequals; }
	;
	
relationalExpression returns [IWSLValue cond]
	: arg=unaryExpression
			{
				ArrayList<IWSLValue> args = null;
				ArrayList<RelationalOperator> ops = null;
			}
		(op=relationalOp argNext=unaryExpression
			{
				if(args == null) {
					args = new ArrayList<IWSLValue>();
					args.add(arg);
				}
				args.add(argNext);
				if(ops == null) {
					ops = new ArrayList<RelationalOperator>();
				}
				ops.add(op);
			}
		)*
			{
				if(args == null || ops == null)
					cond = arg;
				else
					cond = new WSLRelationalCondition(args, ops);
			}
	;

relationalOp returns [RelationalOperator op]
	: '>'			{ op = RelationalOperator.GreaterThan; }
	| '<'			{ op = RelationalOperator.LessThan; }
	| '>='			{ op = RelationalOperator.GreaterThanEqualTo; }
	| '<='			{ op = RelationalOperator.LessThanEqualTo; }
	| 'contains'	{ op = RelationalOperator.Contains; }
	;

unaryExpression returns [IWSLValue cond]
	: ('!' | 'not') arg=unaryExpression	{ cond = new WSLNotCondition(arg); }
	| ('exist' | 'exists') arg=unaryExpression	{ cond = new WSLExistsCondition(arg); }
	| arg=primaryExpression		{ cond = arg; }
	;

parenExpression returns [IWSLValue cond]
	: '(' arg=conditionalExpression ')'		{ cond = arg; }
	;

primaryExpression returns [IWSLValue cond]
	: arg=parenExpression	{ cond = arg; }
	| l=value_list			{ cond = l; }
	;



WHITESPACE
	: { state == State.base || state == State.condition }?=>
		WS+			{ channel = HIDDEN; }
	;
EOL
	: '\r'? '\n' { state = State.base; atStart = true; }
	;
COMMENT
	: { atStart }?=>
		('#'|';') (~('\n'|'\r'))* { channel = HIDDEN; }
	;
LABEL
	: { atStart }?=>
		label=LABEL_STRING ':'			{ setText($label.text); atStart = false; }
	;
VARIABLE
	: '%' var=NORMAL_STRING '%'?
			{
				setText($var.text);
				if(state == State.base) { state = State.command; atStart = false; }
			}
	;
LOCAL_VARIABLE
	:  '$' var=NORMAL_STRING '$'?
			{
				setText($var.text);
				if(state == State.base) { state = State.command; atStart = false; }
			}
	;
IF
	: { state == State.base }?=> 'if' { state = State.condition; atStart = false; }
	;
THEN
	: { state == State.condition }?=> 'then' { state = State.base; }
	;
ACTION
	: { state == State.base }?=> 'action' { state = State.action; atStart = false; }
	;
WHEN
	: { state == State.action }?=> 'when' { state = State.base; }
	;
TRUE
	: { state == State.condition || state == State.action }?=> 'true'
	;
FALSE
	: { state == State.condition || state == State.action }?=> 'false'
	;
NUMBER
	: { state == State.condition || state == State.action }?=> '-'? (DIGIT)+ ('.' (DIGIT)+)?
	;
STRING
	: { state == State.command }?=> (~('%'|'$'|'\n'|'\r'))+
	| { state == State.base }?=> NORMAL_STRING
		{
			state = State.command;
			atStart = false;
		}
	| ('%'|'$')
		{
			if(state == State.base) { state = State.command; atStart = false; }
		}
	| { state == State.condition || state == State.action }?=> (~(WS|'%'|'$'|'\r'|'\n'))+
	| { state == State.condition || state == State.action }?=> '"' str=NQQ_STRING '"' { setText($str.text); }
	| { state == State.condition || state == State.action }?=> '\'' str=NQ_STRING '\'' { setText($str.text); }
	;

fragment WS
	: ' ' | '\t'
	;
fragment DIGIT
	: '0'..'9'
	;
fragment NORMAL_CHAR
	: ('a'..'z'|DIGIT|'_')
	;
fragment NQQ_STRING
	: (~('"'|'%'|'$'|'\n'|'\r'))+
	;
fragment NQ_STRING
	: (~('\''|'%'|'$'|'\n'|'\r'))+
	;
fragment NORMAL_STRING
	: NORMAL_CHAR+
	;
fragment LABEL_STRING
	: NORMAL_CHAR (~(WS|':'|'\n'|'\r'|'%'|'$'))*
	;